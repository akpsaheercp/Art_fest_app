import React, { createContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { 
    doc, onSnapshot, setDoc, updateDoc, collection, 
    query, getDocs, where, deleteDoc, writeBatch, deleteField
} from 'firebase/firestore';
import { 
    signInWithEmailAndPassword, createUserWithEmailAndPassword, 
    signOut, onAuthStateChanged, User as FirebaseUser 
} from 'firebase/auth';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { db, auth, storage } from '../firebase/config';
import { 
    AppState, User, UserRole, ResultStatus, Result, TabulationEntry, 
    ScheduledEvent, Team, Grade, Judge, CodeLetter, Participant, 
    JudgeAssignment, Category, Item, PerformanceType, LogEntry,
    UserProfile, Settings, ItemType, FontConfig, Template, Asset
} from '../types';
import { DEFAULT_PAGE_PERMISSIONS, TABS } from '../constants';

const defaultSettings: Settings = {
    festivalName: 'AMAZIO',
    organizingTeam: 'New Art Fest',
    heading: 'Art Fest 2025',
    description: 'A platform for showcasing talent.',
    maxItemsPerParticipant: { onStage: 5, offStage: 5 },
    defaultParticipantsPerItem: 10,
    instructions: {},
    generalInstructions: 'Welcome!',
    defaultPoints: {
        single: { first: 5, second: 3, third: 1 },
        group: { first: 10, second: 7, third: 5 },
    },
    reportSettings: { heading: 'Report', description: 'Official Document', header: 'Art Fest', footer: 'Generated by App' },
};

interface FirebaseContextType {
  state: AppState | null;
  currentUser: UserProfile | null;
  firebaseUser: FirebaseUser | null; 
  loading: boolean;
  festError: boolean;
  globalFilters: any;
  setGlobalFilters: React.Dispatch<React.SetStateAction<any>>;
  globalSearchTerm: string;
  setGlobalSearchTerm: React.Dispatch<React.SetStateAction<string>>;
  
  dataEntryView: 'ITEMS' | 'PARTICIPANTS';
  setDataEntryView: (v: any) => void;
  itemsSubView: 'ITEMS' | 'PARTICIPANTS';
  setItemsSubView: (v: any) => void;
  gradeSubView: 'CODES' | 'GRADES';
  setGradeSubView: (v: any) => void;
  scoringSubView: 'QUEUE' | 'LEDGER';
  setScoringSubView: (v: any) => void;
  judgesSubView: 'ASSIGNMENTS' | 'REGISTRY' | 'OVERVIEW';
  setJudgesSubView: (v: any) => void;
  settingsSubView: string;
  setSettingsSubView: (v: string) => void;

  login: (email: string, pass: string) => Promise<void>;
  register: (username: string, email: string, pass: string) => Promise<void>;
  setupNewFest: (username: string) => Promise<void>;
  repairOrphanedAccount: () => Promise<void>;
  logout: () => Promise<void>;
  uploadFile: (path: string, file: File) => Promise<string>;

  updateSettings: (payload: Partial<Settings>) => Promise<void>;
  addCategory: (payload: Omit<Category, 'id'>) => Promise<void>;
  updateCategory: (payload: Category) => Promise<void>;
  deleteMultipleCategories: (ids: string[]) => Promise<void>;
  addTeam: (payload: Omit<Team, 'id'>) => Promise<void>;
  updateTeam: (payload: Team) => Promise<void>;
  addMultipleTeams: (payloads: Team[]) => Promise<void>;
  deleteMultipleTeams: (ids: string[]) => Promise<void>;
  addItem: (payload: Omit<Item, 'id'>) => Promise<void>;
  updateItem: (payload: Item) => Promise<void>;
  deleteMultipleItems: (ids: string[]) => Promise<void>;
  addParticipant: (payload: Omit<Participant, 'id'>) => Promise<void>;
  updateParticipant: (payload: Participant) => Promise<void>;
  updateMultipleParticipants: (payload: Participant[]) => Promise<void>;
  addMultipleParticipants: (payloads: Participant[]) => Promise<void>;
  deleteMultipleParticipants: (ids: string[]) => Promise<void>;
  addJudge: (payload: Omit<Judge, 'id'>) => Promise<void>;
  updateJudge: (payload: Judge) => Promise<void>;
  deleteMultipleJudges: (ids: string[]) => Promise<void>;
  addCodeLetter: (payload: Omit<CodeLetter, 'id'>) => Promise<void>;
  addMultipleCodeLetters: (payloads: CodeLetter[]) => Promise<void>;
  deleteCodeLetter: (id: string) => Promise<void>;
  deleteMultipleCodeLetters: (ids: string[]) => Promise<void>;
  addScheduleEvent: (payload: ScheduledEvent) => Promise<void>;
  setSchedule: (payload: ScheduledEvent[]) => Promise<void>;
  updateTabulationEntry: (payload: TabulationEntry) => Promise<void>;
  updateMultipleTabulationEntries: (payload: TabulationEntry[]) => Promise<void>;
  deleteEventTabulation: (itemId: string) => Promise<void>;
  updateResultStatus: (payload: { itemId: string, categoryId: string, status: ResultStatus }) => Promise<void>;
  declareResult: (payload: { itemId: string, categoryId: string }) => Promise<void>;
  updateItemJudges: (payload: { itemId: string, categoryId: string, judgeIds: string[] }) => Promise<void>;
  
  addUser: (payload: Omit<User, 'id'>) => Promise<void>;
  updateUser: (payload: User) => Promise<void>;
  deleteUser: (id: string) => Promise<void>;
  updatePermissions: (payload: { role: UserRole, pages: string[] }) => Promise<void>;
  updateInstruction: (payload: { page: string, text: string }) => Promise<void>;
  hasPermission: (tab: string) => boolean;

  addFont: (font: Omit<FontConfig, 'id'>) => Promise<void>;
  deleteFont: (id: string) => Promise<void>;
  addTemplate: (template: Omit<Template, 'id'>) => Promise<void>;
  deleteTemplate: (id: string) => Promise<void>;
  addAsset: (asset: Omit<Asset, 'id'>) => Promise<void>;
  deleteAsset: (id: string) => Promise<void>;

  addGrade: (payload: { itemType: 'single' | 'group', grade: Omit<Grade, 'id'> }) => Promise<void>;
  updateGrade: (payload: { itemType: 'single' | 'group', grade: Grade }) => Promise<void>;
  deleteGrade: (payload: { itemType: 'single' | 'group', gradeId: string }) => Promise<void>;

  restoreState: (newState: AppState) => Promise<void>;
  resetFestival: () => Promise<void>;
}

export const FirebaseContext = createContext<FirebaseContextType | null>(null);

export const FirebaseProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [firebaseUser, setFirebaseUser] = useState<FirebaseUser | null>(null);
  const [currentUser, setCurrentUser] = useState<UserProfile | null>(null);
  const [state, setState] = useState<AppState | null>(null);
  const [loading, setLoading] = useState(true);
  const [festError, setFestError] = useState(false);
  const [globalFilters, setGlobalFilters] = useState({ teamId: [], categoryId: [], performanceType: [], itemId: [], status: [], date: [], stage: [] });
  const [globalSearchTerm, setGlobalSearchTerm] = useState('');

  const [dataEntryView, setDataEntryView] = useState<'ITEMS' | 'PARTICIPANTS'>('ITEMS');
  const [itemsSubView, setItemsSubView] = useState<'ITEMS' | 'PARTICIPANTS'>('ITEMS');
  const [gradeSubView, setGradeSubView] = useState<'CODES' | 'GRADES'>('CODES');
  const [scoringSubView, setScoringSubView] = useState<'QUEUE' | 'LEDGER'>('QUEUE');
  const [judgesSubView, setJudgesSubView] = useState<'ASSIGNMENTS' | 'REGISTRY' | 'OVERVIEW'>('ASSIGNMENTS');
  const [settingsSubView, setSettingsSubView] = useState('details');

  useEffect(() => {
    const unsubAuth = onAuthStateChanged(auth, async (fUser) => {
        setFirebaseUser(fUser);
        if (fUser) {
            const userDoc = doc(db, 'users', fUser.uid);
            const unsubUser = onSnapshot(userDoc, (snap) => {
                if (snap.exists()) {
                  setCurrentUser(snap.data() as UserProfile);
                } else {
                  setCurrentUser(null);
                  setLoading(false);
                }
            }, (err) => {
                console.warn("User profile loading failed:", err);
                setLoading(false);
            });
            return () => unsubUser();
        } else {
            setCurrentUser(null);
            setState(null);
            setLoading(false);
        }
    });
    return unsubAuth;
  }, []);

  useEffect(() => {
    if (!currentUser?.festId || currentUser.festId.trim() === '') {
        if (!loading && !firebaseUser) setLoading(false);
        setFestError(false);
        return;
    }

    setLoading(true);
    setFestError(false);
    const festId = currentUser.festId;
    const festRef = doc(db, 'fests', festId);

    let assembledState: AppState = {
        settings: defaultSettings,
        categories: [], teams: [], items: [], gradePoints: { single: [], group: [] },
        codeLetters: [], participants: [], schedule: [], judgeAssignments: [],
        tabulation: [], results: [], judges: [], users: [], permissions: DEFAULT_PAGE_PERMISSIONS, logs: [],
        fonts: [], templates: [], assets: []
    };

    const unsubs: (() => void)[] = [];

    // Main Fest Doc
    unsubs.push(onSnapshot(festRef, (snap) => {
        if (snap.exists()) {
            const data = snap.data();
            assembledState.settings = { ...defaultSettings, ...(data.settings || {}) };
            assembledState.gradePoints = data.gradePoints || { single: [], group: [] };
            assembledState.permissions = data.permissions || DEFAULT_PAGE_PERMISSIONS;
            assembledState.users = data.users || [];
            setState({ ...assembledState });
        } else {
            setFestError(true);
            setLoading(false);
        }
    }, (err) => {
        console.error("Fest Root Sync Error:", err);
        setLoading(false);
    }));

    // Subcollections
    const collectionsToListen = [
        'categories', 'teams', 'items', 'participants', 'judges', 
        'codeLetters', 'schedule', 'judgeAssignments', 'tabulation', 'results',
        'fonts', 'templates', 'assets'
    ];

    let collectionsDone = 0;
    collectionsToListen.forEach(colName => {
        const colRef = collection(db, 'fests', festId, colName);
        unsubs.push(onSnapshot(colRef, (snap) => {
            const docs = snap.docs.map(d => ({ ...d.data(), id: d.id }));
            (assembledState as any)[colName] = docs;
            setState({ ...assembledState });
            
            // Mark loading as finished once we have at least one valid snapshot
            // and have attempted to load others
            collectionsDone++;
            if (collectionsDone === collectionsToListen.length) {
              setLoading(false);
            }
        }, (err) => {
            console.warn(`Collection ${colName} Sync Error:`, err);
            collectionsDone++;
            if (collectionsDone === collectionsToListen.length) {
              setLoading(false);
            }
        }));
    });

    // Safety timeout for loading
    const timer = setTimeout(() => setLoading(false), 5000);

    return () => {
      unsubs.forEach(u => u());
      clearTimeout(timer);
    };
  }, [currentUser?.festId]);

  const festDoc = (col: string, id: string) => doc(db, 'fests', currentUser!.festId, col, id);

  const login = async (email: string, pass: string) => {
    await signInWithEmailAndPassword(auth, email, pass);
  };

  const register = async (username: string, email: string, pass: string) => {
    const cred = await createUserWithEmailAndPassword(auth, email, pass);
    await initFest(cred.user.uid, email, username);
  };

  const setupNewFest = async (username: string) => {
      if (!firebaseUser) throw new Error("Not authenticated");
      await initFest(firebaseUser.uid, firebaseUser.email || '', username);
  };

  const repairOrphanedAccount = async () => {
      if (!firebaseUser) return;
      await updateDoc(doc(db, 'users', firebaseUser.uid), {
          festId: deleteField()
      });
      setCurrentUser(prev => prev ? { ...prev, festId: '' } : null);
      setFestError(false);
  };

  const initFest = async (uid: string, email: string, username: string) => {
    const festId = `fest_${Date.now()}`;
    const batch = writeBatch(db);
    batch.set(doc(db, 'fests', festId), {
        id: festId,
        settings: { ...defaultSettings, heading: `${username}'s Fest` },
        gradePoints: { single: [], group: [] },
        permissions: DEFAULT_PAGE_PERMISSIONS,
        users: [],
        createdAt: new Date().toISOString()
    });
    batch.set(doc(db, 'users', uid), {
        uid: uid,
        email,
        username,
        role: UserRole.MANAGER,
        festId
    });
    await batch.commit();
  };

  const logout = async () => {
    await signOut(auth);
  };

  const uploadFile = async (path: string, file: File) => {
    if (!currentUser?.festId) throw new Error("Not logged in");
    const storageRef = ref(storage, `${currentUser.festId}/${path}`);
    await uploadBytes(storageRef, file);
    return getDownloadURL(storageRef);
  };

  const updateSettings = async (payload: Partial<Settings>) => {
    await updateDoc(doc(db, 'fests', currentUser!.festId), { settings: { ...state?.settings, ...payload } });
  };

  const addCategory = async (p: any) => {
    const id = `cat_${Date.now()}`;
    await setDoc(festDoc('categories', id), { ...p, id });
  };

  const updateCategory = async (p: any) => await setDoc(festDoc('categories', p.id), p);

  const deleteMultipleCategories = async (ids: string[]) => {
      const batch = writeBatch(db);
      ids.forEach(id => batch.delete(festDoc('categories', id)));
      await batch.commit();
  };

  const addTeam = async (p: any) => {
    const id = `team_${Date.now()}`;
    await setDoc(festDoc('teams', id), { ...p, id });
  };

  const updateTeam = async (p: any) => await setDoc(festDoc('teams', p.id), p);

  const addMultipleTeams = async (payloads: Team[]) => {
      const batch = writeBatch(db);
      payloads.forEach(t => batch.set(festDoc('teams', t.id), t));
      await batch.commit();
  };

  const deleteMultipleTeams = async (ids: string[]) => {
      const batch = writeBatch(db);
      ids.forEach(id => batch.delete(festDoc('teams', id)));
      await batch.commit();
  };

  const addItem = async (p: any) => {
    const id = `item_${Date.now()}`;
    await setDoc(festDoc('items', id), { ...p, id });
  };

  const updateItem = async (p: any) => await setDoc(festDoc('items', p.id), p);

  const deleteMultipleItems = async (ids: string[]) => {
      const batch = writeBatch(db);
      ids.forEach(id => batch.delete(festDoc('items', id)));
      await batch.commit();
  };

  const addParticipant = async (p: any) => {
    const id = `part_${Date.now()}`;
    await setDoc(festDoc('participants', id), { ...p, id });
  };

  const updateParticipant = async (p: any) => await setDoc(festDoc('participants', p.id), p);

  const updateMultipleParticipants = async (payloads: Participant[]) => {
      const batch = writeBatch(db);
      payloads.forEach(p => batch.set(festDoc('participants', p.id), p));
      await batch.commit();
  };

  const addMultipleParticipants = async (payloads: Participant[]) => {
      const batch = writeBatch(db);
      payloads.forEach(p => batch.set(festDoc('participants', p.id), p));
      await batch.commit();
  };

  const deleteMultipleParticipants = async (ids: string[]) => {
      const batch = writeBatch(db);
      ids.forEach(id => batch.delete(festDoc('participants', id)));
      await batch.commit();
  };

  const addJudge = async (p: any) => {
    const id = `judge_${Date.now()}`;
    await setDoc(festDoc('judges', id), { ...p, id });
  };

  const updateJudge = async (p: any) => await setDoc(festDoc('judges', p.id), p);

  const deleteMultipleJudges = async (ids: string[]) => {
      const batch = writeBatch(db);
      ids.forEach(id => batch.delete(festDoc('judges', id)));
      await batch.commit();
  };

  const addCodeLetter = async (p: any) => {
    const id = `code_${Date.now()}`;
    await setDoc(festDoc('codeLetters', id), { ...p, id });
  };

  const addMultipleCodeLetters = async (payloads: CodeLetter[]) => {
      const batch = writeBatch(db);
      payloads.forEach(p => {
          const id = p.id || `code_${Math.random().toString(36).substr(2, 9)}`;
          batch.set(festDoc('codeLetters', id), { ...p, id });
      });
      await batch.commit();
  };

  const deleteCodeLetter = async (id: string) => await deleteDoc(festDoc('codeLetters', id));

  const deleteMultipleCodeLetters = async (ids: string[]) => {
      const batch = writeBatch(db);
      ids.forEach(id => batch.delete(festDoc('codeLetters', id)));
      await batch.commit();
  };

  const addScheduleEvent = async (p: any) => {
      const id = p.id || `sch_${Date.now()}`;
      await setDoc(festDoc('schedule', id), { ...p, id });
  };

  const setSchedule = async (payloads: ScheduledEvent[]) => {
      const batch = writeBatch(db);
      const existing = await getDocs(collection(db, 'fests', currentUser!.festId, 'schedule'));
      existing.forEach(d => batch.delete(d.ref));
      payloads.forEach(p => batch.set(festDoc('schedule', p.id), p));
      await batch.commit();
  };

  const updateTabulationEntry = async (p: any) => {
      const validMarks = Object.values(p.marks || {}).filter(m => m !== null) as number[];
      p.finalMark = validMarks.length > 0 ? validMarks.reduce((a, b) => a + b, 0) / validMarks.length : null;
      await setDoc(festDoc('tabulation', p.id), p);
  };

  const updateMultipleTabulationEntries = async (payloads: TabulationEntry[]) => {
      const batch = writeBatch(db);
      payloads.forEach(p => batch.set(festDoc('tabulation', p.id), p));
      await batch.commit();
  };

  const deleteEventTabulation = async (itemId: string) => {
      const q = query(collection(db, 'fests', currentUser!.festId, 'tabulation'), where('itemId', '==', itemId));
      const snaps = await getDocs(q);
      const batch = writeBatch(db);
      snaps.forEach(d => batch.delete(d.ref));
      await batch.commit();
  };

  const updateResultStatus = async (p: any) => {
      const id = `${p.itemId}-${p.categoryId}`;
      await setDoc(festDoc('results', id), p, { merge: true });
  };

  const declareResult = async (p: any) => {
      const q = query(collection(db, 'fests', currentUser!.festId, 'tabulation'), where('itemId', '==', p.itemId), where('categoryId', '==', p.categoryId));
      const snaps = await getDocs(q);
      const entries = snaps.docs.map(d => d.data() as TabulationEntry);
      const item = state?.items.find(i => i.id === p.itemId);
      if (!item) return;
      const sorted = [...entries].sort((a,b) => (b.finalMark || 0) - (a.finalMark || 0));
      const uniqueMarks = [...new Set(sorted.map(s => s.finalMark).filter(m => m !== null))].sort((a: any, b: any) => b - a);
      const gradeConfig = item.type === ItemType.SINGLE ? state!.gradePoints.single : state!.gradePoints.group;
      const winners = sorted.map(entry => {
          const markRank = uniqueMarks.indexOf(entry.finalMark) + 1;
          const grade = entry.finalMark !== null ? gradeConfig.find(g => entry.finalMark! >= g.lowerLimit && entry.finalMark! <= g.upperLimit) : null;
          return { participantId: entry.participantId, position: markRank <= 3 ? markRank : 0, mark: entry.finalMark, gradeId: grade?.id || null };
      });
      const resultId = `${p.itemId}-${p.categoryId}`;
      await setDoc(festDoc('results', resultId), { itemId: p.itemId, categoryId: p.categoryId, status: ResultStatus.DECLARED, winners });
  };

  const updateItemJudges = async (p: any) => {
      const id = `${p.itemId}-${p.categoryId}`;
      await setDoc(festDoc('judgeAssignments', id), { ...p, id });
  };

  const addUser = async (p: any) => {
      const users = [...(state?.users || []), { ...p, id: `u_${Date.now()}` }];
      await updateDoc(doc(db, 'fests', currentUser!.festId), { users });
  };

  const updateUser = async (p: any) => {
      const users = state?.users.map(u => u.id === p.id ? p : u) || [];
      await updateDoc(doc(db, 'fests', currentUser!.festId), { users });
  };

  const deleteUser = async (id: string) => {
      const users = state?.users.filter(u => u.id !== id) || [];
      await updateDoc(doc(db, 'fests', currentUser!.festId), { users });
  };

  const updatePermissions = async (p: any) => {
      const permissions = { ...state?.permissions, [p.role]: p.pages };
      await updateDoc(doc(db, 'fests', currentUser!.festId), { permissions });
  };

  const updateInstruction = async (p: any) => {
      const instructions = { ...state?.settings.instructions, [p.page]: p.text };
      await updateDoc(doc(db, 'fests', currentUser!.festId), { 'settings.instructions': instructions });
  };

  const hasPermission = useCallback((tab: string) => {
      if (!currentUser || !state) return false;
      return state.permissions[currentUser.role]?.includes(tab) || false;
  }, [currentUser, state]);

  const addFont = async (f: any) => {
      const id = f.id || `font_${Date.now()}`;
      await setDoc(festDoc('fonts', id), { ...f, id });
  };
  const deleteFont = async (id: string) => await deleteDoc(festDoc('fonts', id));
  
  const addTemplate = async (t: any) => {
      const id = t.id || `tpl_${Date.now()}`;
      await setDoc(festDoc('templates', id), { ...t, id });
  };
  const deleteTemplate = async (id: string) => await deleteDoc(festDoc('templates', id));

  const addAsset = async (a: any) => {
      const id = a.id || `ast_${Date.now()}`;
      await setDoc(festDoc('assets', id), { ...a, id });
  };
  const deleteAsset = async (id: string) => await deleteDoc(festDoc('assets', id));

  const addGrade = async (p: { itemType: 'single' | 'group', grade: Omit<Grade, 'id'> }) => {
      const id = `grade_${Date.now()}`;
      const grades = [...(state?.gradePoints[p.itemType] || []), { ...p.grade, id }];
      await updateDoc(doc(db, 'fests', currentUser!.festId), { [`gradePoints.${p.itemType}`]: grades });
  };

  const updateGrade = async (p: { itemType: 'single' | 'group', grade: Grade }) => {
      const grades = state?.gradePoints[p.itemType].map(g => g.id === p.grade.id ? p.grade : g) || [];
      await updateDoc(doc(db, 'fests', currentUser!.festId), { [`gradePoints.${p.itemType}`]: grades });
  };

  const deleteGrade = async (p: { itemType: 'single' | 'group', gradeId: string }) => {
      const grades = state?.gradePoints[p.itemType].filter(g => g.id !== p.gradeId) || [];
      await updateDoc(doc(db, 'fests', currentUser!.festId), { [`gradePoints.${p.itemType}`]: grades });
  };

  const restoreState = async (newState: AppState) => {
      if (!currentUser?.festId) return;
      const festId = currentUser.festId;
      
      const collectionKeys = [
          'categories', 'teams', 'items', 'participants', 'judges', 
          'codeLetters', 'schedule', 'judgeAssignments', 'tabulation', 'results',
          'fonts', 'templates', 'assets'
      ];

      for (const key of collectionKeys) {
          const q = query(collection(db, 'fests', festId, key));
          const snap = await getDocs(q);
          if (snap.docs.length > 0) {
              for (let i = 0; i < snap.docs.length; i += 500) {
                  const batch = writeBatch(db);
                  snap.docs.slice(i, i + 500).forEach(d => batch.delete(d.ref));
                  await batch.commit();
              }
          }
      }

      await setDoc(doc(db, 'fests', festId), {
          id: festId,
          settings: newState.settings || defaultSettings,
          gradePoints: newState.gradePoints || { single: [], group: [] },
          permissions: newState.permissions || DEFAULT_PAGE_PERMISSIONS,
          users: newState.users || [],
          updatedAt: new Date().toISOString()
      }, { merge: true });

      for (const key of collectionKeys) {
          const items = (newState as any)[key] || [];
          if (items.length === 0) continue;
          
          for (let i = 0; i < items.length; i += 500) {
              const batch = writeBatch(db);
              const chunk = items.slice(i, i + 500);
              chunk.forEach((item: any) => {
                  if (item.id) {
                      batch.set(doc(db, 'fests', festId, key, item.id), item);
                  }
              });
              await batch.commit();
          }
      }
  };

  const resetFestival = async () => {
      if (!currentUser?.festId || !state) return;
      if (!confirm("DANGER: This will delete ALL competitive data. Continue?")) return;
      
      const festId = currentUser.festId;
      const collectionKeys = [
          'categories', 'teams', 'items', 'participants', 'judges', 
          'codeLetters', 'schedule', 'judgeAssignments', 'tabulation', 'results'
      ];

      for (const key of collectionKeys) {
          const q = query(collection(db, 'fests', festId, key));
          const snap = await getDocs(q);
          for (let i = 0; i < snap.docs.length; i += 500) {
              const batch = writeBatch(db);
              snap.docs.slice(i, i + 500).forEach(d => batch.delete(d.ref));
              await batch.commit();
          }
      }
  };

  return (
    <FirebaseContext.Provider value={{
      state, currentUser, firebaseUser, loading, festError, globalFilters, setGlobalFilters,
      globalSearchTerm, setGlobalSearchTerm, dataEntryView, setDataEntryView,
      itemsSubView, setItemsSubView, gradeSubView, setGradeSubView, scoringSubView, setScoringSubView,
      judgesSubView, setJudgesSubView, settingsSubView, setSettingsSubView,
      login, register, setupNewFest, repairOrphanedAccount, logout, uploadFile,
      updateSettings, addCategory, updateCategory, deleteMultipleCategories,
      addTeam, updateTeam, addMultipleTeams, deleteMultipleTeams,
      addItem, updateItem, deleteMultipleItems,
      addParticipant, updateParticipant, updateMultipleParticipants, addMultipleParticipants, deleteMultipleParticipants,
      addJudge, updateJudge, deleteMultipleJudges,
      addCodeLetter, addMultipleCodeLetters, deleteCodeLetter, deleteMultipleCodeLetters,
      addScheduleEvent, setSchedule, updateTabulationEntry, updateMultipleTabulationEntries,
      deleteEventTabulation, updateResultStatus, declareResult, updateItemJudges,
      addUser, updateUser, deleteUser, updatePermissions, updateInstruction, hasPermission,
      addFont, deleteFont, addTemplate, deleteTemplate, addAsset, deleteAsset,
      addGrade, updateGrade, deleteGrade,
      restoreState, resetFestival
    }}>
      {children}
    </FirebaseContext.Provider>
  );
};
